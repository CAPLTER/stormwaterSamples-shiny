#' @title Module to faciliate uploading lachat data
#'
#' @description The module lachat facilitates uploading lachat data. The user
#' attaches the appropriate sample details to uploaded data. Upon execution,
#' the munged data with sample and analysis details is written to
#' stormwater.results upon which, if successful, the imported data are written
#' to stormwater.lachat.
#'
#' @export

# upload UI ---------------------------------------------------------------

upload_lachatUI <- function(id) {

  ns <- shiny::NS(id)

  tagList(

    shiny::fluidPage(
      shiny::fluidRow(

        shiny::column(
          id = "leftPanel", 2,
          shiny::helpText(
            "IMPORTANT: check this box first if data to upload are nitrite (NO2)",
            style = "font-weight: bold; color: DarkBlue;"
            ),
          shiny::checkboxInput(
            inputId = ns("nitriteFlag"),
            label   = HTML('<p style="color: #800080; font-weight: bold;">nitrite?</p>')
            ),
          machineInputUI(ns("samples_for_lachat")) # ns(wrap call to inner mod)
          ), # close the left col

        shiny::column(
          id = "rightPanel", 10,
          DT::dataTableOutput(ns("resultView")),
          shiny::uiOutput(ns("mergedPreviewDivider")),
          DT::dataTableOutput(ns("resultsMetadataView"))
        ) # close the right col

      ) # close the row
    ) # close the page

  ) # close tagList

} # close lachatUI


# upload main -------------------------------------------------------------

upload_lachat <- function(id, tab = NULL) {

  shiny::moduleServer(id, function(input, output, session) {

    # create listener for adding and deleting records
    # listener <- reactiveValues(dbVersion = 0)

    # call module machineInput: builds sample list & machine file import
    machineInputs <- machineInput("samples_for_lachat")


    # helper function for reading input functions; for reasons that are completely
    # unclear, this function only works if included in app.R or function section
    # if a module (i.e., it is loaded but does not seem to work if loaded from
    # helper_shiny_input.R)
    shinyValue <- function(id, len) {
      unlist(lapply(seq_len(len), function(i) {
          value = input[[paste0(id, i)]]
          if (is.null(value)) NA else value
      }))
    }


    # import and process machine output ---------------------------------------

    # raw data imported from output (file)
    rawReactive <- shiny::reactive({

      # require file input
      req(machineInputs$machineFile())

      # import file and remove rows without concentration data
      lachatUpload <- readxl::read_excel(
        path = machineInputs$machineFile()$datapath
        ) |>
      dplyr::filter(!is.na(`Peak Concentration`))

      # check data structure - warning only, does not break workflow
      if (ncol(lachatUpload) != 28) {

        shiny::showNotification(
          ui          = "unexpected data structure: check number and names of columns",
          duration    = NULL,
          closeButton = TRUE,
          type        = "warning"
        )

      }

      # add filename as a variable
      lachatUpload$filename <- machineInputs$machineFile()$name

      # format column names
      colnames(lachatUpload) <- tolower(colnames(lachatUpload))             # colnames to lowercase
      colnames(lachatUpload) <- gsub("\\.", "\\_", colnames(lachatUpload))  # replace dots with underscores
      colnames(lachatUpload) <- gsub(" ", "\\_", colnames(lachatUpload))    # replace spaces with underscores

      lachatUpload <- lachatUpload |>
      dplyr::rename(weight_units = `weight_(units)`)

      # add run identifier as maxrun
      maxrun              <- as.numeric(run_interpolated_query(interpolatedQuery = "SELECT MAX(run_id) FROM stormwater.results;"))
      lachatUpload$run_id <- maxrun + 1

      # add a join field
      lachatUpload <- lachatUpload |>
      dplyr::mutate(
        idToJoin = toupper(trimws(sample_id)),
        idToJoin = gsub("(\\w+\\.\\w+)(\\s[0-9].+)", "\\1", idToJoin),
        idToJoin = dplyr::case_when(
          grepl("unknown", sample_type, ignore.case = T) ~ gsub("\\.", "\\_", idToJoin),
          TRUE ~ idToJoin
        )
      )

      # join lachat to sample list but only it if can be done without creating ambiguous samples
      if (nrow(lachatUpload |> dplyr::left_join(machineInputs$samples(), by = c("idToJoin" = "bottle"))) > nrow(lachatUpload)) {

        lachatUpload <- lachatUpload |>
        dplyr::mutate(samples = as.character(NA))

        shiny::showNotification(
          ui          = "cannot guess sample IDs, enter all IDs or try narrowing the range of sample choices",
          duration    = NULL,
          closeButton = TRUE,
          type        = "warning"
        )

      } else {

        lachatUpload <- lachatUpload |>
        dplyr::left_join(
          machineInputs$samples() |> dplyr::select(-sample_id),
          by = c("idToJoin" = "bottle")
        )

      }

      return(lachatUpload)

    })


    # results reactive --------------------------------------------------------

    resultReactive <- shiny::reactive({

      lachatResults <- rawReactive() |>
      dplyr::filter(
        grepl("unknown", sample_type, ignore.case = TRUE),
        !grepl("om|tres|tr", sample_id, ignore.case = TRUE),
      )

      return(lachatResults)

    })

    # add visual separator between dynamic data and preview of data to upload
    output$mergedPreviewDivider <- shiny::renderUI({

      req(machineInputs$machineFile())

      shiny::tagList(
        br(),
        p("preview data to upload",
          style = "text-align: left; background-color: LightGray; color: black;")
      )

    })


    # render results ----------------------------------------------------------

    output$resultView <- DT::renderDataTable({

      resultReactive() |>
      dplyr::mutate(
        newSample = shinyInputOther(
          FUN     = selectInput,
          len     = nrow(resultReactive()),
          id      = paste0(session$ns("newSample_")),
          choices = c("NULL", machineInputs$samples()$samples),
          width   = "220px"
          ),
        omit = shinyInputOther(
          FUN   = checkboxInput,
          len   = nrow(resultReactive()),
          id    = paste0(session$ns("omit_")),
          value = FALSE,
          width = "20px"
          ),
        replicate = shinyInputOther(
          FUN     = selectInput,
          len     = nrow(resultReactive()),
          id      = paste0(session$ns("rep_")),
          choices = c(1,2,3),
          width   = "40px"
          ),
        comments = shinyInputOther(
          FUN    = textInput,
          len    = nrow(resultReactive()),
          id     = paste0(session$ns("comments_")),
          width  = "120px"
        )
        ) |>
      dplyr::select(samples, newSample, omit, replicate, comments, everything()) |>
      dplyr::select(-idToJoin, -run_id)

    },
    selection = "none",
    escape    = FALSE,
    server    = TRUE, # use server-side to accomodate large tables
    options   = list(
      bFilter         = 0,
      bLengthChange   = FALSE,
      bPaginate       = FALSE,
      bSort           = FALSE,
      preDrawCallback = JS('function() {
        Shiny.unbindAll(this.api().table().node()); }'),
        drawCallback  = JS('function() {
          Shiny.bindAll(this.api().table().node()); } ')
          ),
        rownames = FALSE
      ) # close output$rawView


      # capture file upload and provided data
      resultsMetadata <- shiny::reactive({

        resultReactive() |>
        dplyr::mutate(
          newSample = shinyValue(
            id = "newSample_",
            len = nrow(resultReactive())
            ),
          omit = shinyValue(
            id = "omit_",
            len = nrow(resultReactive())
            ),
          replicate = shinyValue(
            id = "rep_",
            len = nrow(resultReactive())
            ),
          comments = shinyValue(
            id = "comments_",
            len = nrow(resultReactive())
          )
          ) |>
        dplyr::mutate(
          newSample = as.character(newSample),
          comments  = gsub(",", ";", comments),
          comments  = gsub("[\r\n]", "; ", comments)
          ) |> # cast newSample to char to avoid case_when logical errors
        dplyr::filter(omit == FALSE)

      })


      # preview data table with provided metadata
      output$resultsMetadataView <- DT::renderDataTable({

        resultsMetadata() |>
        dplyr::mutate(
          comments = dplyr::case_when(
            grepl("blk", sample_id, ignore.case = T) & comments == "" ~ "blank",
            grepl("blk", sample_id, ignore.case = T) & comments != "" ~ paste(comments, "blank", sep = "; "),
            TRUE ~ as.character(comments))
          ) |>
        dplyr::mutate(
          newSample = replace(newSample, newSample == "NULL", NA),
          samples   = dplyr::case_when(
            !is.na(newSample) ~ newSample,
            TRUE ~ samples
          )
          ) |>
        dplyr::mutate(
          detection_date = as.character(detection_date),
          detection_time = as.character(detection_time, format = "%H:%M:%S")
          ) |>
        dplyr::select(-omit) |>
        dplyr::select(samples, replicate, comments, sample_id, cup_number, detection_date, detection_time, analyte_name, conc_x_adf_x_mdf)

      },
      selection = "none",
      escape    = FALSE,
      server    = FALSE,
      options   = list(
        bFilter       = 0,
        bLengthChange = FALSE,
        bPaginate     = FALSE,
        bSort         = FALSE
        ),
      rownames = FALSE
      ) # close output$resultsMetadataView


      # write data to database --------------------------------------------------

      shiny::observeEvent(machineInputs$submit(), {

        # validate sample IDs
        sample_ids_message <- check_sample_ids(resultsMetadata())

        if (length(sample_ids_message) != 0) {

          notification_message <- paste(sample_ids_message, collapse = " & ")

          shiny::showNotification(
            ui          = notification_message,
            duration    = 8,
            closeButton = TRUE,
            type        = "error"
          )

        } else {

          alpha <- upload_chemistry(
            this_raw_reactive     = rawReactive(),
            this_results_reactive = resultsMetadata(),
            this_samples_metadata = machineInputs$samples(),
            this_analysis         = tab(),
            this_is_nitrite       = input$nitriteFlag # passed for lachat only
          )

          print(paste0("alpha: ", alpha))


# updateCheckboxInput(
#   inputId,
#   label = NULL,
#   value = NULL
# )

#           insert_raw_query <- prepare_raw(
#             raw_reactive = rawReactive(),
#             analysis     = tab()
#           )
# 
# 
#           if (grepl("lachat", tab(), ignore.case = TRUE)) {
# 
#             check_nitrite <- input$nitriteFlag
# 
#           }
# 
# 
#           insert_results_query <- prepare_results(
#             results_reactive = resultsMetadata(),
#             samples_metadata = machineInputs$samples(),
#             analysis         = tab(),
#             is_nitrite       = check_nitrite
#           )
# 
# 
#           # begin tryCatch - transaction
#           tryCatch({
# 
#             poolWithTransaction(this_pool, function(conn) {
# 
#               DBI::dbExecute(
#                 conn,
#                 insert_raw_query
#               )
# 
#               DBI::dbExecute(
#                 conn,
#                 insert_results_query
#               )
# 
#           })
# 
#             shiny::showNotification(
#               ui          = "successfully uploaded",
#               duration    = NULL,
#               closeButton = TRUE,
#               type        = 'message',
#               action      = a(href = "javascript:location.reload();", "reload the page")
#             )
# 
#           }, warning = function(warn) {
# 
#             shiny::showNotification(
#               ui          = paste("there is a warning:  ", warn),
#               duration    = NULL,
#               closeButton = TRUE,
#               type        = "warning"
#             )
# 
#             print(paste("WARNING: ", warn))
# 
#           }, error = function(err) {
# 
#             shiny::showNotification(
#               ui          = paste("there was an error:  ", err),
#               duration    = NULL,
#               closeButton = TRUE,
#               type        = "error"
#             )
# 
#             print(paste("ERROR: ", err))
#             print("ROLLING BACK TRANSACTION")
# 
#           }) # close try catch

        } # close database operations


        # remove temporary tables

#         remove_table(
#           schema_name = "stormwater",
#           table_name  = "temp_results"
#         )

        remove_table(
          schema_name = "stormwater",
          table_name  = "temp_raw"
        )

      }) # close submitData


      # debugging: module level -------------------------------------------------

      # observe(print({ machineInputs$samples() }))
      # observe(write_csv(machineInputs$samples(), '~/Desktop/machineinputs.csv'))
      # observe(write_csv(rawReactive(), '~/Desktop/rawreactive.csv'))
      # observe(print({ rawReactive() }))
      # observe(print({ resultsMetadata() }))
      # observe(print({ str(resultsMetadata()) }))
      # observe(print({ head(resultReactive()) }))


      # close module lachat ----------------------------------------------------

}) # close module server
} # close module function
