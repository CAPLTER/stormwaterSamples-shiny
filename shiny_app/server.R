server <- function(input, output, session) {

  # file upload -------------------------------------------------------------

  # helper function for reading input functions; for reasons that are completely
  # unclear, this function only works if included in app.R (i.e., it is loaded
  # but does not seem to work if loaded from helper_shiny_input.R)
  shinyValue <- function(id, len) {
    unlist(
      lapply(seq_len(len), function(i) {
        value = input[[paste0(id, i)]]
        if (is.null(value)) NA else value
}
      )
    )
  }


  # listeners ------------------------------------------------------------------

  listener_init("update_sample")
  listener_init("update_solid")


  # modules --------------------------------------------------------------------

  upload_report("upload_report") # upload 6700 sample report
  samples_inventory("samples_inventory") # manage samples data
  solids_inventory("solids_inventory") # manage samples data


  # call to viewDischarge module --------------------------------------------

  callModule(
    module = viewDischarge,
    id = "viewDischarge"
  )


  # discharge upload --------------------------------------------------------

  # site id from file upload
  levelDataSiteId <- reactive({

    req(input$dischargeFile)

    readr::read_csv(
      file = input$dischargeFile$datapath,
      n_max = 1,
      col_names = c("reportText", "siteID")) %>%
    dplyr::select(siteID) %>%
    unlist(., use.names = FALSE)

  })


  # level data from file upload
  levelData <- reactive({

    req(input$dischargeFile)

    readr::read_csv(
      file = input$dischargeFile$datapath,
      skip = 7,
      col_names = c("event_datetime", "level")
      ) %>%
    dplyr::filter(!is.na(event_datetime)) %>%
    dplyr::mutate(
      event_datetime = lubridate::parse_date_time(event_datetime, c("mdY HMS p", "mdY HMS")),
      event_datetime = format(event_datetime, "%Y-%m-%d %H:%M:%S"),
      site_id = levelDataSiteId(),
      site_id = as.integer(site_id),
      source_file = input$dischargeFile$name
      ) %>%
    dplyr::select(
      site_id,
      event_datetime,
      water_height = level,
      source_file
    )

  })


  # preview data table with upload and provided values
  output$levelDataPreview <- renderTable({

    levelData()

  })


  # write discharge data to database
  observeEvent(input$submitDischargeFileUpload, {

    # modify data object as needed for the DB
    dischargeToWrite <- levelData() %>%
      dplyr::mutate(
        event_datetime = as.POSIXct(event_datetime, format = "%Y-%m-%d %H:%M:%S")
      )

    # add run identifier as maxrun
    maxrun <- as.numeric(run_interpolated_query(interpolatedQuery = "SELECT MAX(run_id) FROM stormwater.discharge ;"))

    if (is.na(maxrun) | is.null(maxrun)) { maxrun <- 0 }

    dischargeToWrite$run_id <- maxrun + 1

    # write temp table
    if (dbExistsTable(stormPool, c('stormwater', 'discharge_temp'))) {

      dbRemoveTable(stormPool, c('stormwater', 'discharge_temp'))

    }

    dbWriteTable(
      conn = stormPool,
      name = c('stormwater', 'discharge_temp'),
      value = dischargeToWrite,
      row.names = F
    )

    # remove timezone type generated by dbWriteTable function
    remove_timezone_query <- '
    ALTER TABLE stormwater.discharge_temp
    ALTER COLUMN event_datetime TYPE TIMESTAMP WITHOUT TIME ZONE ;'

    run_interpolated_execution(interpolatedQuery = remove_timezone_query)

    # write temp data to database

    # insert into samples. the 'ON CONFLICT' clause allows for skipping
    # inserting any data that are already in the database.
    insertLevelDataQuery <- '
    INSERT INTO stormwater.discharge
    (
      site_id,
      event_datetime,
      water_height,
      source_file,
      run_id
    )
    (
      SELECT
      site_id,
      event_datetime,
      water_height,
      source_file,
      run_id
      FROM
      stormwater.discharge_temp
    )
    ON CONFLICT ON CONSTRAINT discharge_unique_observations DO NOTHING;'

    # write temp data to database
    run_interpolated_execution(
      interpolatedQuery = insertLevelDataQuery, 
      success_notice = TRUE
    )

    # remove temporary table
    if (dbExistsTable(stormPool, c('stormwater', 'discharge_temp'))) {

      dbRemoveTable(stormPool, c('stormwater', 'discharge_temp'))

    }


  }) # close observe event upload level data


  # establish tab position as input to modules ------------------------------

  tabID <- reactive({ input$tabs })


  # call to cations module --------------------------------------------------

  callModule(module = cations,
    id = "icpCations",
    tab = tabID)


  # call to lachat module ---------------------------------------------------

  callModule(module = lachat,
    id = "lachat",
    tab = tabID)


  # call to aq2 module ---------------------------------------------------

  callModule(module = aq2,
    id = "aq2",
    tab = tabID)


  # call to shimadzu module ---------------------------------------------------

  callModule(module = shimadzu,
    id = "shimadzu",
    tab = tabID)


  # call to chem viewer module ----------------------------------------------

  ChemViewer1$call()

  # call to chem inventory module ----------------------------------------------

  ChemInventory1$call()


  # debugging ---------------------------------------------------------------

  # observe(print({ input$tabs }))
  # observe(print({ solidsDataReactive() }))
  # observe(print({ listenModifySolids$dbVersion }))
  # observe(print({ queryType$default }))
  # observe(print({ input$solidsData_cell_edit }))


  # close server ------------------------------------------------------------

}
